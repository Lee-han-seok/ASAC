# -*- coding: utf-8 -*-
"""8.클래스_객체.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-z1f_mToD20Z3PRktPuTV-zxt1o-TvId

# 1. Class

- 개념
    - C++, JAVA에서 시작
    - Entity(엔티티) -> 표현하고자 하는 대상이라고 이해해보자
        - 개체, 이 세상에 존재하는 모든 유형, 무형(개념, 이론...)을 대변한다
        - class로 묘사할 수 있는 대상
    - 이런 엔티티를 프로그램 세상에서 표현하기 위해서 도구, 방식, 문법, 절차, 룰 필요 -> 이런 룰을 정의한것이 바로 class이다.

# 2. object : 객체

- 전제 : Python 언어에서 class 문법에 따라 엔티티를 묘사했다. (작성했다)
- 이렇게 작성된 class가 실행되기 위해서는 생성이라는 행위를 수행해야한다.
    - 일반적인 객체 지향언어 -> new class이름()
    - 파이썬 -> class이름()
- 메모리상에 class의 모습을 본딴 형태로 하나의 인스턴스가 만들어진다.
    - 클레스의 인스턴스가 객체라고 부른다
    - 객체는 반드시 주소를 가진다.
    - 객체는 여러개 만들 수 있다. (같은 모습을 본딴 형태로)
        - obj = Man()
        - obj를 객체라고 부른다(Man의 인스턴스를 가르킨다)

# 3. class의 문법

- 클래스명은 통상적 첫글자 대문자, 이어지는 글자 소문자
- 클래스내에서 자기 자신을 가리키는 키워드
    - self : 파이썬, objective-C, ...
        - 멤버 함수의 1번 인자로 통상 사용
        - 타 맴버를 클레스 내부에서 엑세스할 때 self.xx와 같이 접근
    - this : 대부분의 언어

```
class 클래스명[ ( [부모클레스] ) ]: # 클레스 선언문
    # 생성자 함수 -> 생략 가능함
    def __init__(self, [인자]):
        # 인스턴스 변수를 통상적으로 초기화한다
        # 인스턴스 변수를 사용하기 전에만 초기화 하면된다.
    # 클레스 변수
        # 생성자 혹은 맴버함수들과 같은 레벨(위치)에서 정의됨
        # 사용법 => 클레스.변수
    # 맴버함수
    def 함수명(self, [인자]):
        # 구현내용
    # 모든 클레스의 수퍼클래스로부터 상속받은 함수들
        # 클래스라면 무조건 가지고 있는 함수들
        # __xx__라는 이름을 가진다
```

# 4. 클래스 구현

### 4-1. 생성
"""

# 클래스 정의
# 요구사항 : person이라는 class를 만드시오

class Person: pass

# 생성 => 클래스명()
p = Person()
id(p) # id값 출력
p1 = Person()
# 클레스는 객체는 여러번 생성할 수 있다.
id(p), id(p1)

"""### 4-2. 해제

- 메모리상에서 제거
    - 파이썬은 참조카운터를 줄인다.
"""

del p
del p1

"""### 4-3. 기본 구성원을 늘려서 생성"""

# 요구사항
# Person 클레스를 구성하시오
# Person은 age, name을 데이터를 가진다 -> 데이터 -> 변수(인스턴스 혹은 클레스 변수) or 맴버변수(통상)
# Person은 eat(밥을 먹는다), wear(옷을 입는다), run(달린다)등 행동을 할수 있다 -> 행동 -> (맴버)함수
class Person:
    '''
        Person 클레스
    '''
    # 클레스 변수
    age = 10
    # 생성자 => 주로 맴버 변수들(주로 인스턴 변수들)을 초기화 한다(생성시 전달해주는 외부 데이터로 )
    # 생성자를 재정의 했다
    def __init__(self, name):
        # 외부에서 데이터를 전달받아서 맴버 변수 name을 할당하여 값을 초기화 한다
        # 인스턴스 변수 초기화가 1순위 (배치상)
        self.name = name
        #self.eat()

    # 맴버 함수
    def eat(self):
        print( f'{self.name}는 주식을 밥을 먹는다')
    def wear(self):
        print( f'{self.name}는 옷을 입는다')
    def run(self):
        print( f'{self.name}는 달린다')

    pass

p = Person( '공덕' )

# p객체의 age값, name값을 출력하시오
# age, name은 person의 맴버 이고, 접근법 => 객체명.멤버
# 클래스 변수는 객체 생성 없이도 접근 가능 => 정적변수로 관리해도 무방함
p.name, p.age, Person.age

p.eat()
p.wear()
p.run()

# 클래스 변수를 인스턴스 변수 방식으로 접근한것
# 클래스형 변수는 인스턴스 변수처럼 사용하는것을 비추(사용하지 않는다!)
print(p.age)
p.age = 20 # 클래스형 변수를 인스턴스 방식으로 접근하면 다른 주소로 사용된다.
p.age, Person.age, id(p.age), id(Person.age)

"""### 4-4. 상속

- 객체 지향적 프로그래밍(OOP)
    - 특징중에 하나
    - 특정 클래스의 자식을 구현, 부모의 유산을 모두 그대로 사용가능, 추가, 업그레이드 가능(over riding)
        - 부모 클레스 => 자식 클레스
            - 상속
            - 부모 클레스 has a 자식 클레스
        - 자식 클레스 => 부모 클레스
            - 추상화
            - 자식 클레스 is a 부모 클레스

"""

# Person 클레스를 업그레이드 해서XMan 클레스로 정의해보자.
class XMan(Person):
    pass

x = XMan('울버린')
x.name, x.eat()

# Person 클레스를 업그레이드 해서XMan 클레스로 정의해보자.
class XMan2(Person):
    '''
        부모의 모든 기능을 그대로 상속받고,
        특정 기능은 재정의(업그레이드) 하겠다.
    '''
    def eat(self):
        print( f'{self.name}는 주식을 밥을 2배속으로 빠르게 먹는다')
    def attack(self):
        print( f'{self.name}는 갈고리 공격이 가능하다.')
    pass

x = XMan2('울버린')
x.name, x.eat(), x.attack()

# 3세대
class XMan3(XMan2) :
    '''
        속성(변수) 추가 -> 레벨 추가됨
    '''
    def __init__(self, name:str, level:int) -> None :
        # self.name = name <- 이 기능을 새로 만들 필요 없이 부모의 유산을 활용한다.
        # 부모를 지칭하는 말 -> super
        super().__init__(name)
        # 내가 추가한 코드
        self.level = level
        pass

x3 = XMan3('뉴울버린', 100)
x3.level, x3.name, x3.eat(), x3.attack(), x3.run()

"""## 4-5. class에 소속됨 함수 종류

- 인스턴스 함수


```
        def ...
```
- 클레스 함수(메소드)
    - 객체를 생성하지 않아도 사용 가능
    - 클래스명.함수
    - 클래스 변수 접근 OK, 인스턴스 변수는 X


```
        @classmethod
        def ...
        
```


- 정적 함수(메소드)
    - 유틸리티 기능 등 통상적으로 이런 유형
    - pure한 함수들이 포함
    - 객체 생성 필요 없음



```
@staticmethod
        def ...
        
```
"""

'''
     클레스 구성, 클레스함수(메소드), 정적함수(메소드) 예시
     모든 클레스의 수퍼클레스는 Object (모든 객체지향언어의 공통점)
     클레스명( 수퍼클레스가 생략되어 있다 ):
     클레스명:
'''
class Sample_Method():
    m = 0
    @classmethod
    def class_func( cls ):
        '''
            cls : 클레스
            cls.m : 클레스 변수
            명시적으로 인자값을 전달하지는 않는다 -> 함수 호출할때
        '''
        print('클레스 변수 엑세스 가능', cls.m)
        pass

    @staticmethod
    def static_func():
        '''
            pure한(순수) 함수 스타일
            클레스 변수, 인스턴 변수 일체 사용하지 않는다
            함수 단독으로 특정 기능을 담당하는 함수
        '''
        a = 100
        print( '정적함수 호출', a)
        pass

# 클레스 메소드 호출
Sample_Method.class_func()
Sample_Method.static_func()

"""#5. 객체 지향 프로그래밍 특징

- 캡슐화
    - 데이터를 은닉한다.
    - 외부에서는 반드시 객체를 통해서만 접근 가능하다
    - access 레벨을 부여하여 컨트롤 가능
        - 타 언어는 4단계 레벨 존재
        - 파이썬은 2단계 (공개(public), 비공개(private))
            - 별도의 키워드는 없음
            - **비공개는 __(두개의 밑줄)을 활용하여서 표현** <- 외부 접근 못하고 노출 X
            - _(한개의 밑줄)은 개발자가 굳이 알 필요 없다라는 느낌

- 상속성
    - 부모, 자식간 상속, 위에서 설명
- 다형성
    - 재정의 (overfitting)
    - 하나의 모습에서 상속을 타고 다양한 모습으로 진화할 수 있다. (변수, 함수) <- 상속을 통해서 구현 가능
"""

class Private_Test():
    # 생성자
    def __init__(self, _a : int):
        self.__a = _a
        self._b = _a
        pass
    # 프라이빗 함수
    def __private_func(self):
        print('숨겨진함수', self.__a)
    # _ 추가한 함수
    def _private_func(self):
        print('함수', self._b)

    # 부모로 부터 받은 함수들중 중요함수
    # 소멸자(객체를 해제할대 호출) <-> 생성자
    def __del__(self):
        # 해제시 작업 사항이 존재하면 구현, 없으면 생략
        print('객체 해제')
    # 객체를 설명하는 함수 -> print() 사용으로 출력하는 함수
    def __str__(self):
        # 재정의 않하면 기본값 < 클레스명,... 객체주소 > 출력
        # 재정의 => 맴버변수들을 출력하여 값을 확인하는 용도
        return '< 객체 설명 기술함 >'
    # 객체를 설명하는 함수 -> print() 사용X 그냥 값으로 출력되는 함수
    def __repr__(self):
        # 재정의 않하면 기본값 < 클레스명,... 객체주소 > 출력
        # 재정의 => 맴버변수들을 출력하여 값을 확인하는 용도
        return '< 객체 설명 기술함2 >'


o = Private_Test(10)
print( o )
o

obj = Private_test(11)
del obj

# __변수 => 숨김 처리가 되었다.
o._b. # 에러 발생함

# __함수
o._Private_Test__private_func()

# 특정 변수가 가진 모든 요소를 출력하시오 => dir()

print(dir(o))

# 숨겨진 요소가 다른 이름으로 변경되서 관리되고 있었다 => 네임 맹글리(mamgling) 기법
# 타 언어에서는 컴파일시 이름을 중복되는 것을 방지하기 위해서 이름을 변경하게 된다 -> 맹글리
o._Private_Test__a